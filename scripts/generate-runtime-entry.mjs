import { promises as fs } from 'fs';
import { existsSync } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

async function main() {
  const pkgPath = path.join(projectRoot, 'package.json');
  const pkgRaw = await fs.readFile(pkgPath, 'utf8');
  const pkg = JSON.parse(pkgRaw);
  const fallbackEntry = 'dist/index.js';
  const mainField = typeof pkg.main === 'string' && pkg.main.trim() ? pkg.main.trim() : fallbackEntry;
  const resolvedEntry = path.resolve(projectRoot, mainField);

  if (!existsSync(resolvedEntry)) {
    throw new Error(`Build output not found at ${path.relative(projectRoot, resolvedEntry)} (package.json#main)`);
  }

  const distDir = path.join(projectRoot, 'dist');
  await fs.mkdir(distDir, { recursive: true });

  const runtimeEntryPath = path.join(distDir, 'index.js');
  const relativeImport = path.relative(path.dirname(runtimeEntryPath), resolvedEntry).replace(/\\/g, '/');
  const normalizedImport = relativeImport.startsWith('.') ? relativeImport : `./${relativeImport}`;

  const banner = '// Auto-generated by scripts/generate-runtime-entry.mjs\n';
  const contents = `${banner}import '${normalizedImport}';\n`;

  await fs.writeFile(runtimeEntryPath, contents, 'utf8');
  console.log(`[build] Runtime entry created at ${path.relative(projectRoot, runtimeEntryPath)} -> ${normalizedImport}`);
}

main().catch((error) => {
  console.error(`[build] Failed to create runtime entry: ${error.message}`);
  process.exit(1);
});
